
1-1.  나중에 해당 타일들에 대한 조작 및 접근을 용이하게 하려고 타일들을 찾아서 Tiles 에 저장함. 이렇게 하면  코드 상에서 마우스 위치에 가장 가까운 타일을 찾거나, 건설 여부를 확인하거나 할 때 배열을 통해 쉽게 처리할 수 있다는 장점이 있음

1-2. 게임 시작 시에는 숨겨놓고, 이후에 특정 조건이 충족될 때만 활성화되도록 하는데 사용하기 위해서

1-3. UpdateBuildImage에서 ? 연산자는 *삼항 연산자*로, bCanBuild가 참이면 BuildCanMat을, 거짓이면 BuildCanNotMat을 선택하는 구문.

1-4. if(bFocusTile) else 코드는 현재 마우스 위치에 타일이 존재하는지 여부를 확인하는 작업을 거치는 것입니다.

1-5. CheckToBuildGuardian에서 DeActiveBuildImage는 건설이 완료되면 건설 아이콘을 숨기기 위해 호출됩니다.


2-0. 스크립터블 오브젝트는 무엇일까?, 어떻게 만들고? 어떻게 사용할까? 공부하기 ->

스크립터블 오브젝트 (ScriptableObject): Unity에서 데이터를 효율적으로 저장하고 관리하기 위한 클래스로, 프로젝트 설정, 리소스 데이터, 게임 설정 등을 저장할 때 사용됩니다.
만들기: 프로젝트 창에서 우클릭 -> Create -> Scriptable Object 선택하여 생성하며, C# 클래스를 정의하여 데이터 구조를 생성합니다.
사용하기: Inspector에서 해당 오브젝트를 생성하고, 코드에서 해당 스크립터블 오브젝트에 접근하여 데이터를 읽거나 쓸 수 있습니다. 주로 데이터 관리와 조직화에 활용됩니다.
2-1. Guardian의 SearchEnemy는 어떻게 작동하고 있을까? ->

SearchEnemy 함수는 Guardian이 현재 감지한 적들 중에서 최대 타겟 수(MaxTargetCount)에 따라 타겟을 선택합니다.
최대 타겟 수에 도달하면 더 이상 새로운 타겟을 추가하지 않고, 이미 감지된 적 중에서 타겟 수만큼만을 유지합니다.
2-2. OnTriggerStay, Exit는 왜 만들었을까? ->

OnTriggerStay는 Guardian이 적에게 접촉 중일 때 호출되며, 감지된 적을 _targetEnemys 리스트에 추가합니다.
OnTriggerExit는 Guardian이 적과의 접촉이 끝날 때 호출되어, _targetEnemys 리스트에서 해당 적을 제거합니다.
두 함수를 통해 Guardian은 주변의 적을 지속적으로 감지하고, 이 정보를 업데이트하여 유지합니다.
2-3. Guardian들의 공격 범위는 어떻게 설정하고 있을까? ->

Guardian의 공격 범위는 GetComponent<SphereCollider>().radius = GuardianStatus.AttackRadius; 코드를 사용하여 설정됩니다.
SphereCollider 컴포넌트의 반지름이 GuardianStatus.AttackRadius 값으로 설정되어, 해당 범위 내에 있는 적을 감지할 수 있게 됩니다.